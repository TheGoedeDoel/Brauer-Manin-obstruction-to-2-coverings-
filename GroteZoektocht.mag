P2<U, V, W> := ProjectivePlane(Rationals());
R<X> := PolynomialRing(Rationals());
D := EllipticCurveDatabase();
N := ; 

CurvesE := EllipticCurves(D, N);
m := #CurvesE;
TateE := []; 
for E in CurvesE do 
rank, gens, sha := MordellWeilShaInformation(E : ShaInfo, Silent := true);
if sha[1][1] eq 2 and sha[1][2][1] gt 0 then 
Append(~TateE, E); 
end if;
end for; 

for E in TateE do 
covers := TwoDescent(E);
Tatecovers := []; 
for C in covers do
if #RationalPoints(C : Bound := 10000) eq 0 then 
Append(~Tatecovers, C); 
end if; 
end for; 
end for; 


if #Tatecovers ge 1 then 
for C in Tatecovers do 
FC<x,y,z> := DefiningPolynomial(C); 
M := [x^4, x^3*z,x^2*z^2,x*z^3,z^4];
F := - (MonomialCoefficient(FC,x^4)*X^4 + MonomialCoefficient(FC, x^3*z)*X^3 + MonomialCoefficient(FC, x^2*z^2)*X^2 + MonomialCoefficient(FC, x*z^3)*X + MonomialCoefficient(FC,z^4));
FF<x,y> := FunctionField(C);
Candidaten := []; 
time for alpha in [-1000..1000] do
for beta in [0..1000] do
if (GCD(alpha,beta) eq 1 and beta ne 0) or (alpha eq 0 and beta eq 1) then
gamma, delta := SquareFree(Integers() ! (Coefficient(F,4)*alpha^4 +Coefficient(F,3)*alpha^3*beta+Coefficient(F,2)*alpha^2*beta^2+Coefficient(F,1)*alpha*beta^3+Coefficient(F,0)*beta^4));
if AbsoluteValue(gamma) lt 200 then 
Append(~Candidaten,[alpha,beta,gamma,delta]);
end if; end if; end for; end for; 
opslag := []; 
NCandidaten := [];
maat := #Candidaten;
for i in [1..maat] do 
for j in [1..maat] do 
if i lt j then 
if Candidaten[i][3] eq Candidaten[j][3] then 
Append(~opslag,[Candidaten[i], Candidaten[j]]); 
end if; end if; 
end for; end for; 

time for paar in opslag do 
R<u> := PolynomialRing(Rationals());
gamma := paar[1][3]; 
f := (x - paar[1][1]/paar[1][2])/(x - paar[2][1]/paar[2][2]);
primes := return_primes(f,paar); 
reciprocity_save := []; 
if #TwoTorsionSubgroup(E) ge 2 then 
time for p in primes do 
prime := p; 
Qp := pAdicField(p, prec); 
gens := pAdic2Descent(E, p, prec);
phi1, phi2, phi3, P := find_map(C, p, prec, breadth); 
values := []; 
for ppp in gens do
pp := ppp[1];  
xxx := (BaseChange(E, Qp) ! pp)[1];
yyy := (BaseChange(E, Qp) ! pp)[2];
zzz := (BaseChange(E, Qp) ! pp)[3];
xx := Evaluate(phi1, [xxx,yyy,zzz]); yy := Evaluate(phi2, [xxx,yyy,zzz]); zz := Evaluate(phi3, [xxx,yyy,zzz]); 

if Valuation(zz) lt 40 then 
imx := xx/zz; imy := yy/zz^2; 
fP := Evaluate(Numerator(f), [imx,imy])/Evaluate(Denominator(f), [imx, imy]);
Append(~values, NormResidueSymbol(Rationals() ! fP, Rationals() ! gamma, p)); 
else 
Append(~values, 1); //the gluing map x -> 1/u implies that fP = 1 
end if; 
end for; 
imx := P[1]; imy := P[2]; 
fP := Evaluate(Numerator(f), [imx,imy])/Evaluate(Denominator(f), [imx, imy]);
Append(~values, NormResidueSymbol(Rationals() ! fP, Rationals() ! gamma, p)); 
Append(~reciprocity_save, <prime, values>); 
end for;
if gamma lt 0 then 
RR := RealField(50); 
FC<xC,yC,zC> := DefiningPolynomial(C); 
M := [xC^4, xC^3*zC,xC^2*zC^2,xC*zC^3,zC^4];
F := - (MonomialCoefficient(FC,xC^4)*u^4 + MonomialCoefficient(FC, xC^3*zC)*u^3 + MonomialCoefficient(FC, xC^2*zC^2)*u^2 + MonomialCoefficient(FC, xC*zC^3)*u + MonomialCoefficient(FC,zC^4));
for xt in [-5000..5000] do 
for zt in [1..5000] do 
a := Evaluate(F, xt/zt); 
if a ge 0 then 
temp, root := IsSquare(RR ! a); 
PR := [xt/zt, root, 1]; 
PR; 
break xt; 
end if;
end for; 
end for; 
imx := PR[1]; imy := PR[2]; 
fP := Evaluate(Numerator(f), [imx,imy])/Evaluate(Denominator(f), [imx, imy]);
if fP ge 0 then 
Append(~reciprocity_save,<0,[1]>);
else  
Append(~reciprocity_save,<0,[-1]>);
end if; 
end if; 
PrintFileMagma("C:/Users/John/Documents/Master's Thesis - Hasse Principle/ou\
tput_file", paar); 
PrintFileMagma("C:/Users/John/Documents/Master's Thesis - Hasse Principle/ou\
tput_file", reciprocity_save); 
end if; //delete 
end for; 


else 
for p in primes do 
prime := p; 
Qp := pAdicField(p, prec); 
gens := twoDescentMijn(E, p, prec);
phi1, phi2, phi3, P := find_map(C, p, prec, breadth); 
values := []; 
for ppp in gens do
pp := ppp[1];  
xxx := (BaseChange(E, Qp) ! pp)[1];
yyy := (BaseChange(E, Qp) ! pp)[2];
zzz := (BaseChange(E, Qp) ! pp)[3];
xx := Evaluate(phi1, [xxx,yyy,zzz]); yy := Evaluate(phi2, [xxx,yyy,zzz]); zz := Evaluate(phi3, [xxx,yyy,zzz]); 
imx := xx/zz; imy := yy/zz^2; 
fP := Evaluate(Numerator(f), [imx,imy])/Evaluate(Denominator(f), [imx, imy]);
Append(~values, NormResidueSymbol(Rationals() ! fP, Rationals() ! gamma, p)); 
end for; 
imx := P[1]; imy := P[2]; 
fP := Evaluate(Numerator(f), [imx,imy])/Evaluate(Denominator(f), [imx, imy]);
Append(~values, NormResidueSymbol(Rationals() ! fP, Rationals() ! gamma, p)); 
Append(~reciprocity_save, <prime, values>); 
end for;
if gamma lt 0 then 
RR := RealField(50); 
FC<xC,yC,zC> := DefiningPolynomial(C); 
M := [xC^4, xC^3*zC,xC^2*zC^2,xC*zC^3,zC^4];
F := - (MonomialCoefficient(FC,xC^4)*u^4 + MonomialCoefficient(FC, xC^3*zC)*u^3 + MonomialCoefficient(FC, xC^2*zC^2)*u^2 + MonomialCoefficient(FC, xC*zC^3)*u + MonomialCoefficient(FC,zC^4));
for xt in [-5000..5000] do 
for zt in [1..5000] do 
a := Evaluate(F, xt/zt); 
if a ge 0 then 
temp, root := IsSquare(RR ! a); 
PR := [xt, root, 1]; 
PR; 
break xt; 
end if;
end for; 
end for; 
imx := PR[1]; imy := PR[2]; 
fP := Evaluate(Numerator(f), [imx,imy])/Evaluate(Denominator(f), [imx, imy]);
if fP ge 0 then 
Append(~reciprocity_save,<0,[1]>);
else  
Append(~reciprocity_save,<0,[-1]>);
end if; 
end if; 

end if; 









































return_primes := function(f,paar)
Df := Divisor(f); L := ResidueClassField(Support(Df)[1]);
OL := MaximalOrder(L);
gamma := paar[1][3];
primes := []; 
Delta := Discriminant(OL);
if #Decomposition(OL,2) eq 1 then 
Append(~primes, 2);
end if;
facttop := Factorisation(paar[1][2]);
factbot := Factorisation(paar[2][2]);
len1 := #facttop;
len2 := #factbot;
if len1 ne 0 then 
for i in [1..len1] do
if #Decomposition(OL, facttop[i][1]) eq 1 and facttop[i][1] ne 2 then
Append(~primes, facttop[i][1]);
end if;
end for;
end if;  
if #factbot ne 0 then 
for i in [1..len2] do
if #Decomposition(OL, factbot[i][1]) eq 1 and factbot[i][1] notin primes then
Append(~primes, factbot[i][1]);
end if;
end for;
end if; 
top1 := Evaluate(F, paar[1][1]/paar[1][2]); 
bot1 := Evaluate(F, paar[2][1]/paar[2][2]); 
facttop11 := Factorisation(Numerator(top1));
facttop12 := Factorisation(Denominator(top1));
factbot11 := Factorisation(Numerator(bot1));
factbot12 := Factorisation(Denominator(bot1));
len11 := #facttop11;
len12 := #facttop12;
len21 := #factbot11;
len22 := #factbot12;
if len11 ne 0 then 
for i in [1..len11] do
if #Decomposition(OL, facttop11[i][1]) eq 1 and facttop11[i][1] notin primes then
Append(~primes, facttop11[i][1]);
end if;
end for;
end if; 
if len12 ne 0 then 
for i in [1..len12] do
if #Decomposition(OL, facttop12[i][1]) eq 1 and facttop12[i][1] notin primes then
Append(~primes, facttop12[i][1]);
end if;
end for;
end if; 
if len21 ne 0 then 
for i in [1..len21] do
if #Decomposition(OL, factbot11[i][1]) eq 1 and factbot11[i][1] notin primes then
Append(~primes, factbot11[i][1]);
end if;
end for;
end if; 
if len22 ne 0 then 
for i in [1..len22] do
if #Decomposition(OL, factbot12[i][1]) eq 1 and factbot12[i][1] notin primes then
Append(~primes, factbot12[i][1]);
end if;
end for;
end if; 
primes2 := [];
for data in Factorisation(Delta) do 
Append(~primes2, data[1]); 
end for; 
primes := Set(primes) join Set(primes2);
return primes; 
end function; 


find_map := function(C, p, prec,breadth)
count := 0; 
R<u> := PolynomialRing(Rationals());
Qp := pAdicField(p, prec); 
FC<x,y,z> := DefiningPolynomial(C); 
M := [x^4, x^3*z,x^2*z^2,x*z^3,z^4];
F := - (MonomialCoefficient(FC,x^4)*u^4 + MonomialCoefficient(FC, x^3*z)*u^3 + MonomialCoefficient(FC, x^2*z^2)*u^2 + MonomialCoefficient(FC, x*z^3)*u + MonomialCoefficient(FC,z^4));
for x in [0..breadth] do 
a := Evaluate(F, x); 
temp, root := IsSquare(Qp ! a); 
if temp then 
K := NumberField(u^2 - a); 
mapK := hom<K -> Qp | root>; 
Kpoly<uK,vK,wK> := PolynomialRing(K,3); 
QpPoly<up, vp, wp> := PolynomialRing(Qp, 3); 
mapKpoly := hom<Kpoly -> QpPoly | mapK, up, vp, wp>; 
CK := BaseChange(C, K); 
EC, phiC := EllipticCurve(CK, CK ! [K ! x, K.1 ,1]); 
EK := BaseChange(E, K); 
psiC := Inverse(phiC); 
lam := Isomorphism(EK, EC);
mapC := lam * psiC; 
h1 := DefiningEquations(mapC)[1]; h2 := DefiningEquations(mapC)[2]; h3 := DefiningEquations(mapC)[3]; 
phi1 := mapKpoly(h1); phi2 := mapKpoly(h2); phi3 := mapKpoly(h3);
xx := x; 
P :=  BaseChange(C, Qp) ! [Qp ! xx, root, Qp ! 1]; 
count := count + 1; 
return phi1, phi2, phi3, P; 
break x; 
end if; end for; 
if count eq 0 then 
temp, point := IsLocallySolvable(C,p); 
xx := Rationals() ! point[1];
a := Evaluate(F, xx); 
temp, root := IsSquare(Qp ! a); 
if temp then 
K := NumberField(u^2 - a); 
mapK := hom<K -> Qp | root>; 
Kpoly<uK,vK,wK> := PolynomialRing(K,3); 
QpPoly<up, vp, wp> := PolynomialRing(Qp, 3); 
mapKpoly := hom<Kpoly -> QpPoly | mapK, up, vp, wp>; 
CK := BaseChange(C, K); 
EC, phiC := EllipticCurve(CK, CK ! [K ! xx, K.1 ,1]); 
EK := BaseChange(E, K); 
psiC := Inverse(phiC); 
lam := Isomorphism(EK, EC);
mapC := lam * psiC; 
h1 := DefiningEquations(mapC)[1]; h2 := DefiningEquations(mapC)[2]; h3 := DefiningEquations(mapC)[3]; 
phi1 := mapKpoly(h1); phi2 := mapKpoly(h2); phi3 := mapKpoly(h3);
P :=  BaseChange(C, Qp) ! [Qp ! xx, root, Qp ! 1]; 
count := count + 1; 
return phi1, phi2, phi3, P; 
end if;
end if; 
end function; 




twoDescentMijn := function(E, p, prec)
generators := []; 
Qp := pAdicField(p,prec);
EE, mapE := WeierstrassModel(E); 
mapE := Inverse(mapE); 
h1 := DefiningEquations(mapE)[1]; h2 := DefiningEquations(mapE)[2]; h3 := DefiningEquations(mapE)[3]; 
FE<u,v,w> := DefiningPolynomial(EE);
d4 := -MonomialCoefficient(FE, u*w^2);
d6 := -MonomialCoefficient(FE, w^3);
K<z> := NumberField(X^3 +d4*X+d6);
OK := MaximalOrder(K);
Ip := Decomposition(OK, p)[1][1];
Kp<b>, mLp := Completion(K,Ip : Precision := prec);
mLg := Inverse(mLp);
Gp, phip := pSelmerGroup(2,Kp);
g := Inverse(phip);
alpha := mLg(b);

Admissabledelta := []; 
for gelt in Gp do 
if gelt ne Gp ! 0 then
delta := mLg(g(gelt));
temp, r := IsSquare((Norm(g(gelt))));
if temp then 
Append(~Admissabledelta, delta); 
end if; 
end if; 
end for; 

failedprimes := [];
if #Admissabledelta eq 0 then 
Append(~failedprimes, p); 
Exclude(~primes, p);
else 
for delta1 in Admissabledelta do 
e2 := delta1[3]; e1 := delta1[2]; e0 := delta1[1]; 
a := e2^2*d4-e0*e2+e1^2;
beta := -e2^2*d6-e0*e1; 
if mLp(delta1[3]) ne 0 then  
temp, r := IsSquare(Qp ! Norm(delta1));
P2<U, V, W> := ProjectivePlane(Rationals());
CU := Curve(P2, a*U^2 + e2 * W^2 - V^2); 
temp, point :=  IsLocallySolvable(CU,p); 
if temp eq false then
hold := 1; 
else 
point := LiftPoint(point, prec : Strict := false);
WW := point[3]/(Qp ! r); VV := (point[2] +beta*WW)/a; 
UU := (point[1]-e1*VV-(e0-e2*d4)*WW)/e2;
u := Rationals()! (UU); v := Rationals()! (VV); w := Rationals()! (WW); 
delta := delta1*(u+v*z+w*z^2)^2; 
aa := (delta[1]);
bb := (-delta[2]);
val := Minimum(Valuation(aa, 2),Valuation(bb,2)); 
if IsDivisibleBy(val, 2) then 
aa := aa/2^(val);
bb := bb/2^(val);
else 
aa := aa/2^(val-1);
bb := bb/2^(val-1);
end if;
aa := Numerator(aa)*Modinv(Denominator(aa), p^(prec)) mod p^prec; 
bb := Numerator(bb)*Modinv(Denominator(bb), p^(prec)) mod p^prec; 
delta := aa - bb*z; 

temp, r := IsSquare(Qp ! Norm(delta));  
H := HyperellipticCurve((4*bb^3)^(-1)*(X^4-(6*aa)*X^2+(8 * Rationals() ! r)*X+(-4*d4*bb^2-3*aa^2)));
temp, point := IsLocallySolvable(H,p);
if temp then 
point  := LiftPoint(point,50 : Strict := false);
lambda := point[1]; y := point[2]; mu := point[3]; 
y^2 - (4*bb^3)^(-1)*(lambda^4-(6*aa)*lambda^2*mu^2+(8*r)*lambda*mu^3+(-4*d4*bb^2-3*aa^2)*mu^4);
(lambda*mu/y)^2 - mu^2/y * lambda^2/y;
w := lambda*mu/(r*y);
v:= (aa*w-mu^2/y)/bb;
u:= (aa*bb*v + (aa^2+2*d4*bb^2)*w-lambda^2/y)/(2*bb^2);

aa*v^2 + (-d4*aa+ d6*bb)*w^2- 2*bb*u*v + 2*aa*u*w +2*d4*bb*v*w;

newprec := Minimum([AbsolutePrecision(u), AbsolutePrecision(v), AbsolutePrecision(w)]); 
x1 := pAdicField(p ,newprec) ! (delta * ( Rationals() ! u +  Rationals() ! v * z +  Rationals() ! w * z^2)^2)[1];
temp, y1 := IsSquare(pAdicField(p ,newprec) ! (x1^3 + (Qp ! d4)*x1 + (Qp ! d6)));
if temp then 
P := [Rationals() ! x1, Rationals() ! y1,1]; 
Q := [Qp ! Evaluate(h1, P), Qp ! Evaluate(h2, P), Qp ! Evaluate(h3, P)]; 
P; 
Append(~generators, Q); 
end if; 
end if; end if; end if; end for; end if; 
return generators; 
end function; 